---
slug: malloc_chunk
title: å†…å­˜æ³„æ¼ ä¸ malloc chunk
author: Ye Shu
author_title: Studying how C++ allocates and frees chunks in memory
author_url: https://github.com/yechs
author_image_url: https://avatars.githubusercontent.com/u/49149993
tags: [c++, pwn]
---

# å†…å­˜æ³„æ¼ ä¸ malloc chunk

## æˆ‘ä¸ºä»€ä¹ˆè¦å†™è¿™ç¯‡æ–‡ç«  {#how-it-all-started}

åœ¨æˆ‘æš‘æœŸå®ä¹ æœŸé—´ debug ä¸€ä¸ªå†…å­˜æ³„æ¼çš„é—®é¢˜æ—¶ï¼Œæˆ‘å‘ç°æˆ‘ä½¿ç”¨çš„å…¶ä¸­ä¸€ä¸ª API return äº†ä¸€ä¸ªè£¸æŒ‡é’ˆï¼Œä»è€ŒæŠŠè¿™ä¸ªç›®æ ‡çš„ ownership è½¬ç§»ç»™äº†è°ƒç”¨è€…ï¼ˆæˆ‘ï¼‰ã€‚æ¢è¨€ä¹‹ï¼Œæˆ‘ç°åœ¨éœ€è¦è´Ÿè´£åœ¨ä»£ç è¿è¡Œå®Œæ¯•ä¹‹åæ‰‹åŠ¨ `delete` æ‰è¿™ä¸ªæŒ‡é’ˆã€‚å°½ç®¡è¿™æ˜¯ä¸€ä¸ª [éå¸¸ç³Ÿç³•çš„å·¥ç¨‹å®è·µ](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t)ï¼Œæˆ‘å¼€å§‹å¯¹å†…å­˜æ³„æ¼æ˜¯å¦‚ä½•äº§ç”Ÿçš„ï¼Œä»¥åŠ `delete[]` æ˜¯å¦‚ä½•åˆ é™¤å†…å­˜çš„äº§ç”Ÿäº†å…´è¶£ã€‚

åœ¨åšäº†ä¸€äº›ç ”ç©¶ä¸å®éªŒåï¼Œæˆ‘å†™ä¸‹äº†è¿™ç¯‡æ–‡ç« ã€‚æœ¬æ–‡å°†è¯•å›¾å›ç­”ä¸‰ç»„é—®é¢˜ï¼š

1. ä»€ä¹ˆæ˜¯å†…å­˜æ³„æ¼ï¼Ÿ
2. å¯¹è±¡æ˜¯å¦‚ä½•åœ¨ å † (heap) ä¸Šè¢«åˆ†é…çš„ï¼Ÿ`delete[]` å¦‚ä½•çŸ¥é“å®ƒéœ€è¦é‡Šæ”¾å“ªå—å†…å­˜ï¼Ÿ
3. æˆ‘ä»¬å¦‚ä½•é¢„é˜²å†…å­˜æ³„æ¼ï¼Ÿ

<!--truncate-->

Stack Overflow ä¸Šçš„é—®é¢˜ ["How does delete[] 'know' the size of the operand array?"](https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array) å…¶å®å·²ç»å¤§è‡´å›ç­”äº†æˆ‘ä»¬çš„ç¬¬äºŒä¸ªé—®é¢˜ï¼Œä½†æˆ‘è¿˜æ˜¯å†³å®šæ›´æ·±å…¥åœ°æ¢è®¨ä¸€ä¸‹å®é™…çš„å†…å­˜ç©ºé—´æ˜¯ä»€ä¹ˆæ ·çš„ã€‚

å·§åˆçš„æ˜¯ï¼Œæˆ‘å’Œæœ‹å‹ [@gzhding](https://guozhen.dev) åˆšå¥½åœ¨æœ€è¿‘çš„ä¸€æ¬¡ CTF æ¯”èµ›ä¸­åˆä½œäº†ä¸€é“ å †åˆ©ç”¨ (heap exploitation) çš„é¢˜ç›®ã€‚å› ä¸ºè¿™ä»½ç»å†ï¼Œæˆ‘å­¦ä¼šäº†å¦‚ä½•ä½¿ç”¨ `gdb` è°ƒè¯•å¹¶æŸ¥çœ‹å †ä¸Šçš„å†…å­˜ï¼Œä»¥å€Ÿå…¶ç®¡ä¸­çª¥è±¹ã€‚

:::info
æ³¨ï¼šæˆ‘å…ˆå†™æˆäº†æœ¬æ–‡çš„è‹±æ–‡ç‰ˆï¼Œä¹‹åæ‰è¯•å›¾å°†å…¶è¯‘å›ä¸­æ–‡ã€‚å› æ­¤å¦‚æœ‰å¯èƒ½çš„è¯ï¼Œè¯·ä»¥è‹±æ–‡é˜…è¯»æœ¬æ–‡ï¼Œä»¥é¿å…ä¸€äº›å› ä¸ºç¿»è¯‘è´¨é‡å¯¼è‡´çš„è¯­å¥ä¸é¡ºä¸ç†è§£å›°éš¾ã€‚
:::

## ä»€ä¹ˆæ˜¯å†…å­˜æ³„æ¼ {#what-are-memory-leaks}

æˆ‘ä»¬çŸ¥é“ [C++ èƒ½å¤Ÿåœ¨å †ä¸ŠåŠ¨æ€åœ°åˆ†é…å†…å­˜](https://www.cplusplus.com/doc/tutorial/dynamic/)ã€‚ä¸€ä¸ªå¸¸è§çš„ä¾‹å­æ˜¯ä½¿ç”¨ `new[]` åˆ›å»ºæ•°ç»„ï¼Œä»¥åŠ `delete[]` åˆ é™¤æ•°ç»„ã€‚

å½“æˆ‘ä»¬åœ¨å†…å­˜ä¸­åˆ›å»ºäº†ä¸€ä¸ªæ•°ç»„ï¼ˆå³åˆ†é…äº†ä¸€æ®µå†…å­˜ç”¨ä»¥å­˜å‚¨è¿™ä¸ªå¯¹è±¡ï¼‰è€Œåˆå¿˜è®°åˆ é™¤å®ƒæ—¶ï¼Œ[å†…å­˜æ³„æ¼](https://en.wikipedia.org/wiki/Memory_leak) å°±ä¼šå‘ç”Ÿã€‚å½“æŒ‡å‘è¿™æ®µå†…å­˜çš„æŒ‡é’ˆè¶…å‡ºä½œç”¨åŸŸ (scope) æ—¶ï¼Œæ­£åœ¨è¿è¡Œçš„ä»£ç å°±ä¸¢å¤±äº†å¯¹è¢«åˆ†é…çš„å†…å­˜çš„çŸ¥è¯†ã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œå¦‚æœå†…å­˜æ³„æ¼åœ¨ä¸€ä¸ªå¾ªç¯ä¸­å‘ç”Ÿï¼Œæ–°åˆ†é…çš„å†…å­˜èƒ½å¤ŸæŒç»­åœ°å †ç§¯è€Œä¸è¢«é‡Šæ”¾ï¼Œæœ€ç»ˆä½¿å¾—ç”µè„‘å˜æ…¢ç”šè‡³å´©æºƒã€‚

### PoC {#poc}

ä»¥ä¸‹æœ‰ä¸€æ®µç®€å•çš„ Proof of Concept (PoC) ä»£ç ã€‚å…¶ä¸­çš„ `main()` å‡½æ•°è°ƒç”¨äº† `memory_leak()` å‡½æ•°ï¼Œåè€…åˆåˆ›å»ºäº†ä¸€ä¸ªç”± 26 ä¸ª `char` ç»„æˆçš„æ•°ç»„ï¼Œå¹¶å°†å¤§å†™è‹±æ–‡å­—æ¯å¡«å…¥å®ƒä»¬ã€‚

```cpp title="memory_leak.cpp"
void memory_leak() {
    // Always delete pointers created by new to avoid memory leaks!
    char *arr = new char[26];

    for (int i = 0; i < 26; i++) {
        arr[i] = char(65 + i); // 65 is the ascii of 'A'
    }

    // The memory area is not freed!
    // delete[] arr;
}

int main() {
    memory_leak();
    return 0;
}
```

å› ä¸º `delete[]` è¯­å¥å·²ç»è¢«æ³¨é‡Šæ‰ï¼Œå½“å‡½æ•° `memory_leak()` return æ—¶ï¼ŒæŒ‡é’ˆ `arr` ä¼šè¶…å‡ºä½œç”¨åŸŸ (scope) å¹¶å¯¼è‡´è¿™ä¸€å†…å­˜åŒºåŸŸè¢«æ³„æ¼ã€‚

### åˆæ¢å†…å­˜ {#a-deeper-look-into-the-memory}

:::note
æˆ‘ä½¿ç”¨äº† [GEF](https://github.com/hugsy/gef) (GDB Enhanced Features) è€Œä¸æ˜¯åŸç”Ÿ GDB ä»¥è·å–ç»è¿‡ç¾åŒ–çš„è¾“å‡ºä»¥åŠè¯¸å¦‚ `heap` ä¸€ç±»çš„é¢å¤–åŠŸèƒ½ã€‚
:::

è®©æˆ‘ä»¬ä»¥ `g++ -g3 memory_leak.cpp -o memory_leak` æ¥ç¼–è¯‘è¿™ä¸ªç¨‹åºï¼ˆ`-g3` flag ä¼šåœ¨ç¼–è¯‘æ—¶ä¿å­˜ç¨‹åºçš„è°ƒè¯•ä¿¡æ¯ï¼‰å¹¶ä½¿ç”¨ `gdb` æ¥éªŒè¯è¿™ä¸€å†…å­˜æ³„æ¼ã€‚

æˆ‘ä»¬å°†ä¼šåœ¨ `memory_leak()` å‡½æ•°çš„æœ€åæ‰“ä¸€ä¸ªæ–­ç‚¹ï¼Œå¹¶è¿è¡Œç¨‹åºç›´åˆ°å…¶è§¦å‘æ–­ç‚¹ã€‚

```console
$ gdb memory_leak

gefâ¤  b 11
Breakpoint 1 at 0x1179: file memory_leak.cpp, line 11.

gefâ¤  r
[...]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ source:memory_leak.cpp+11 â”€â”€â”€â”€
      6          arr[i] = char(65 + i); // 65 is the ascii of 'A'
      7      }
      8
      9      // The memory area is not freed!
     10      // delete[] arr;
â—â†’   11  }
     12
     13  int main() {
     14      memory_leak();
     15      return 0;
     16  }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ threads â”€â”€â”€â”€
[#0] Id 1, Name: "memory_leak", stopped 0x555555555179 in memory_leak (), reason: BREAKPOINT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ trace â”€â”€â”€â”€
[#0] 0x555555555179 â†’ memory_leak()
[#1] 0x555555555186 â†’ main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

gefâ¤  info locals
arr = 0x55555556aeb0 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

gefâ¤  x/8xw 0x55555556aeb0
0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d
0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000
```

åœ¨ç¨‹åºè§¦å‘æ–­ç‚¹åï¼Œæˆ‘ä»¬æ‰“å°å‡ºæŒ‡é’ˆ `arr` æŒ‡å‘çš„åœ°å€åŠè¿™å—å†…å­˜çš„å†…å®¹ã€‚æ³¨æ„å†…å­˜æ˜¯ä»¥ [å°ç«¯åº](https://zh.wikipedia.org/zh-cn/%E5%AD%97%E8%8A%82%E5%BA%8F#%E5%B0%8F%E7%AB%AF%E5%BA%8F) å­˜å‚¨çš„ï¼Œå› æ­¤ `0x44` (D) æ’åœ¨ `0x43` (C)ï¼Œ`0x42` (B)ï¼Œä»¥åŠ `0x41` (A) ä¹‹å‰ã€‚

ç°åœ¨ï¼Œè®©æˆ‘ä»¬ç»§ç»­è¿è¡Œè¿™ä¸ªç¨‹åºï¼Œç›´åˆ°å‡½æ•° `memory_leak()` è¿è¡Œå®Œæ¯•è¿”å›è‡³ `main()`ã€‚

```gdb
gefâ¤  finish
[...]
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ source:memory_leak.cpp+15 â”€â”€â”€â”€
     10      // delete[] arr;
â—    11  }
     12
     13  int main() {
     14      memory_leak();
 â†’   15      return 0;
     16  }
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ threads â”€â”€â”€â”€
[#0] Id 1, Name: "memory_leak", stopped 0x555555555186 in main (), reason: TEMPORARY BREAKPOINT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ trace â”€â”€â”€â”€
[#0] 0x555555555186 â†’ main()
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

gefâ¤  info locals
No locals.

gefâ¤  x/8xw 0x55555556aeb0
0x55555556aeb0: 0x44434241      0x48474645      0x4c4b4a49      0x504f4e4d
0x55555556aec0: 0x54535251      0x58575655      0x00005a59      0x00000000
```

<!-- gefâ¤  heap chunks
Chunk(addr=0x555555559010, size=0x290, flags=PREV_INUSE)
    [0x0000555555559010     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x5555555592a0, size=0x11c10, flags=PREV_INUSE)
    [0x00005555555592a0     00 1c 01 00 00 00 00 00 00 00 00 00 00 00 00 00    ................]
Chunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)
    [0x000055555556aeb0     41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50    ABCDEFGHIJKLMNOP]
Chunk(addr=0x55555556aee0, size=0xf130, flags=PREV_INUSE)  â†  top chunk -->

æ—¢ç„¶ `memory_leak()` return äº†ï¼Œæˆ‘ä»¬å°±ä¸¢å¤±äº†æŒ‡å‘å†…å­˜åœ°å€ `0x55555556aeb0` çš„æŒ‡é’ˆ `arr`ã€‚ä½†å½“æˆ‘ä»¬æ‰“å°å‡ºå†…å­˜åŒºåŸŸæ—¶ï¼Œå‘ç°è¿™äº›æ•°æ®ä»ç„¶å­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œæ²¡æœ‰ï¼ˆä¹Ÿä¸ä¼šï¼‰è¢«é‡Šæ”¾ã€‚è¿™å°±æ˜¯å†…å­˜æ³„æ¼ã€‚

### åˆ©ç”¨ Valgrind è¿›è¡ŒéªŒè¯ {#verification-with-valgrind}

æ­¤å¤–ï¼Œæˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨å¦‚ [Valgrind](https://valgrind.org) ä¸€æ ·çš„è‡ªåŠ¨åŒ–å·¥å…·æ¥æ£€æŸ¥å†…å­˜æ³„æ¼ã€‚

```console
$ valgrind --leak-check=full ./memory_leak
==382643== Memcheck, a memory error detector
==382643== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==382643== Using Valgrind-3.17.0 and LibVEX; rerun with -h for copyright info
==382643== Command: ./memory_leak
==382643==
==382643==
==382643== HEAP SUMMARY:
==382643==     in use at exit: 26 bytes in 1 blocks
==382643==   total heap usage: 2 allocs, 1 frees, 72,730 bytes allocated
==382643==
==382643== 26 bytes in 1 blocks are definitely lost in loss record 1 of 1
==382643==    at 0x484021F: operator new[](unsigned long) (vg_replace_malloc.c:579)
==382643==    by 0x10914A: memory_leak() (memory_leak.cpp:3)
==382643==    by 0x109185: main (memory_leak.cpp:14)
==382643==
==382643== LEAK SUMMARY:
==382643==    definitely lost: 26 bytes in 1 blocks
==382643==    indirectly lost: 0 bytes in 0 blocks
==382643==      possibly lost: 0 bytes in 0 blocks
==382643==    still reachable: 0 bytes in 0 blocks
==382643==         suppressed: 0 bytes in 0 blocks
==382643==
==382643== For lists of detected and suppressed errors, rerun with: -s
==382643== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
```

## å¯¹è±¡æ˜¯å¦‚ä½•åœ¨å † (heap) ä¸Šè¢«åˆ†é…çš„ {#how-are-objects-allocated-on-the-heap}

ä¸ºäº†æ›´å¥½åœ°ç†è§£å†…å­˜æ³„æ¼èƒŒåçš„æœºåˆ¶ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ C++ æ˜¯å¦‚ä½•åˆ†é…ä»¥åŠé‡Šæ”¾å†…å­˜çš„ã€‚æ¢è¨€ä¹‹ï¼Œ`new` ä¸ `delete` æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚è®©æˆ‘ä»¬ä¸€èµ·æ·±å…¥è¿› GNU çš„ `libstdc++` å®ç°ï¼ˆg++ é»˜è®¤ä½¿ç”¨çš„åº“ï¼‰çš„æºç ã€‚

### `new` ä¸ `delete` æ˜¯å¦‚ä½•å·¥ä½œçš„ {#how-new-and-delete-works}

:::info
å› ä¸º `new` ä¸ `delete` æ“ä½œç¬¦ä»…ä»…æ˜¯ C++ æ ‡å‡†ä¸­å®šä¹‰çš„ interfaceï¼Œå®ƒä»¬æ‹¥æœ‰ä¸åŒçš„å®ç°ã€‚æˆ‘åœ¨æ­¤å¤„å°†ä½¿ç”¨ GNU åœ¨ gcc 11.2 ç‰ˆæœ¬ä¸­æä¾›çš„ `libstdc++` çš„ [æºç ](https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0)ã€‚

#### `new[]` å’Œ `delete[]` åªæ˜¯å¯¹ `new` å’Œ `delete` çš„å°è£… {#new-and-delete-are-just-wrappers-of-new-and-delete}

æœ‰æ„æ€çš„æ˜¯ï¼Œä» `operator new[]` çš„å®ç°ï¼ˆ[æºç ](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_opv.cc#L29-L33)ï¼‰æ¥çœ‹ï¼Œ`new[]` åœ¨ `stdlibc++` ä¸­åªæ˜¯ `new` çš„ä¸€ä¸ªåˆ«åã€‚

```cpp title="/libstdc++-v3/libsupc++/new_opv.cc:L29-33"
_GLIBCXX_WEAK_DEFINITION void*
operator new[] (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)
{
  return ::operator new(sz);
}
```

å¯¹ `delete[]`ï¼ˆ[æºç ](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_opv.cc#L32-L36)ï¼‰è€Œè¨€äº¦æ˜¯å¦‚æ­¤ï¼Œå®ƒä¸è¿‡æ˜¯ `delete` çš„åˆ«åã€‚

:::caution
æ ¹æ® GNU stdlibc++ çš„å®ç°æ¥çœ‹ï¼Œä¼¼ä¹æ··åˆä½¿ç”¨ `new[]` ä¸ `new`ï¼Œä»¥åŠ `delete[]` ä¸ `delete` æ˜¯å®Œå…¨å¯ä»¥æ¥å—çš„ã€‚

ä½†æ˜¯ï¼Œä½ åº”å½“é¿å…è¿™ä¹ˆåšï¼Œå› ä¸ºè¿™ç§è¡Œä¸ºæ˜¯å–å†³äºå®ç°çš„ã€‚æ ¹æ® [C++ Working Paper](https://timsong-cpp.github.io/cppwp/expr.delete#2)ï¼Œä½¿ç”¨ `new` å’Œ `delete` è€Œä¸æ˜¯ `new[]` å’Œ `delete[]` ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºï¼Œè¿™ä¼šä½¿è°ƒè¯•å˜å¾—ä¸€å›¢ç³Ÿã€‚
:::

#### è€Œ `new` å’Œ `delete` ä¸è¿‡æ˜¯å¯¹ `malloc` å’Œ `free` çš„å°è£… {#and-new--delete-are-wrappers-of-malloc-and-free}

è®©æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹çœ‹ `new` çš„ [æºç ](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/new_op.cc#L41-L59)ã€‚å®ƒä¹Ÿåªæ˜¯ä¸€ä¸ªå¯¹ C ä¸­çš„ `malloc` åŠ ä¸Šä¸€äº›é”™è¯¯å¤„ç†çš„å°è£…ï¼Œå¹¶ä¼šåœ¨æœ€åç»™è°ƒç”¨è€… return ä¸€ä¸ª `malloc` è¿”å›çš„åŸå§‹æŒ‡é’ˆã€‚

```cpp title="/libstdc++-v3/libsupc++/new_op.cc:L41-59"
_GLIBCXX_WEAK_DEFINITION void *
operator new (std::size_t sz) _GLIBCXX_THROW (std::bad_alloc)
{
  void *p;

  /* malloc (0) is unpredictable; avoid it.  */
  if (__builtin_expect (sz == 0, false))
    sz = 1;

  while ((p = malloc (sz)) == 0)
    {
      new_handler handler = std::get_new_handler ();
      if (! handler)
	_GLIBCXX_THROW_OR_ABORT(bad_alloc());
      handler ();
    }

  return p;
}
```

`delete`ï¼ˆ[æºç ](https://github.com/gcc-mirror/gcc/blob/releases/gcc-11.2.0/libstdc++-v3/libsupc++/del_op.cc#L46-L50)ï¼‰æ›´åŠ ç®€å•ï¼Œç›´æ¥è°ƒç”¨äº† C ä¸­çš„ `free`ã€‚

```cpp title="libstdc++-v3/libsupc++/del_op.cc:L46-50"
_GLIBCXX_WEAK_DEFINITION void
operator delete(void* ptr) noexcept
{
  std::free(ptr);
}
```

<!-- ### How `malloc` and `free` works -->

è¿™æ ·ä¸€æ¥ï¼Œæˆ‘ä»¬ä¼¼ä¹éœ€è¦ä¸€è·¯æ·±å…¥åˆ° C æ ‡å‡†åº“ä¸­å¯¹ `malloc` ä¸ `free` çš„å®ç°æ‰èƒ½çŸ¥é“åœ¨æ•°ç»„çš„åˆ›å»ºä¸é”€æ¯èƒŒåç©¶ç«Ÿå‘ç”Ÿäº†ä»€ä¹ˆã€‚

ç„¶è€Œï¼Œæˆ‘ä»¬ä¸ä¼šæ¶µç›–ä¸ `malloc` ç›¸å…³çš„å…¨éƒ¨å†…å®¹ï¼ˆè¿™äº›å†…å®¹æœ¬èº«å°±è¶³å¤Ÿæ’‘èµ·å¦å¤–ä¸€ç¯‡æ–‡ç« äº†ï¼‰ï¼Œæˆ‘ä»¬å°†ä¸»è¦å…³æ³¨ `malloc` å¦‚ä½•ç»„ç»‡å®ƒåˆ†é…çš„å†…å­˜ç©ºé—´ï¼ˆç­”æ¡ˆï¼šåœ¨å †ä¸Šæ„å»º `malloc_chunk`ï¼‰ä»¥åŠ `free` æ˜¯å¦‚ä½•çŸ¥é“å»é‡Šæ”¾å“ªå—å†…å­˜çš„ã€‚

### `malloc_chunk` çš„ç»“æ„æ˜¯ä»€ä¹ˆæ ·çš„? {#how-are-malloc_chunks-structured}

:::info
ä¸ä¸ŠèŠ‚ä¸€æ ·ï¼Œæˆ‘å°†ä½¿ç”¨ GNU å¯¹ C æ ‡å‡†åº“çš„å®ç°, å³ `glibc`ã€‚
glibc çš„å½“å‰ç‰ˆæœ¬æ˜¯åœ¨ 2021 å¹´ 8 æœˆ 2 æ—¥ release å‡ºçš„ [glibc 2.34](https://sourceware.org/git/?p=glibc.git;a=tag;h=refs/tags/glibc-2.34)ã€‚
:::

ä»¥ä¸‹å†…å®¹æ¥è‡ª glibc ä¸­ `malloc/malloc.c` çš„æ³¨é‡Šï¼ˆ[æºç ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1168)ï¼‰ã€‚ä»¥ä¸‹å†…å®¹ä¸ºè‹±æ–‡åŸæ–‡ï¼Œæˆ‘å¯èƒ½ä¼šåœ¨ä¹‹åæŸä¸ªæ—¶å€™è€ƒè™‘å°†å…¶ç¿»è¯‘ä¸ºä¸­æ–‡ã€‚æˆ‘åœ¨åŸæ–‡ä¹‹ä¸Šè¿›è¡Œäº†ä¸€äº›å¾®å°çš„ç¼–è¾‘ä»¥å°†å…¶é€‚é…ä¸º Markdown æ ¼å¼ï¼ˆæœ¬ç½‘ç«™ä½¿ç”¨çš„æ ¼å¼åŒ–å·¥å…·ï¼‰ã€‚

> (The following includes lightly edited explanations by Colin Plumb.)
>
> Chunks of memory are maintained using a `boundary tag' method as
> described in e.g., Knuth or Standish. (See the paper by Paul
> Wilson [ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps](ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps) for a
> survey of such techniques.) Sizes of free chunks are stored both
> in the front of each chunk and at the end. This makes
> consolidating fragmented chunks into bigger chunks very fast. The
> size fields also hold bits representing whether chunks are free or
> in use.
>
> An allocated chunk looks like this:
>
> ```
>     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Size of previous chunk, if unallocated (P clear)  |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Size of chunk, in bytes                     |A|M|P|
>       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             User data starts here...                          .
>             .                                                               .
>             .             (malloc_usable_size() bytes)                      .
>             .                                                               |
> nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             (size of chunk, but used for application data)    |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Size of next chunk, in bytes                |A|0|1|
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
> ```
>
> Where "chunk" is the front of the chunk for the purpose of most of
> the malloc code, but "mem" is the pointer that is returned to the
> user. "Nextchunk" is the beginning of the next contiguous chunk.
>
> Chunks always begin on even word boundaries, so the mem portion
> (which is returned to the user) is also on an even word boundary, and
> thus at least double-word aligned.
>
> Free chunks are stored in circular doubly-linked lists, and look like this:
>
> ```
>     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Size of previous chunk, if unallocated (P clear)  |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>     `head:' |             Size of chunk, in bytes                     |A|0|P|
>       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Forward pointer to next chunk in list             |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Back pointer to previous chunk in list            |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Unused space (may be 0 bytes long)                .
>             .                                                               .
>             .                                                               |
> nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>     `foot:' |             Size of chunk, in bytes                           |
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
>             |             Size of next chunk, in bytes                |A|0|0|
>             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
> ```
>
> The P (`PREV_INUSE`) bit, stored in the unused low-order bit of the
> chunk size (which is always a multiple of two words), is an in-use
> bit for the _previous_ chunk. If that bit is _clear_, then the
> word before the current chunk size contains the previous chunk
> size, and can be used to find the front of the previous chunk.
> The very first chunk allocated always has this bit set,
> preventing access to non-existent (or non-owned) memory. If
> `prev_inuse` is set for any given chunk, then you CANNOT determine
> the size of the previous chunk, and might even get a memory
> addressing fault when trying to do so.
>
> [...]
>
> Note that the `foot` of the current chunk is actually represented
> as the `prev_size` of the NEXT chunk. This makes it easier to
> deal with alignments etc but can be very confusing when trying
> to extend or adapt this code.
>
> [...]

### åˆ©ç”¨ PoC ä»£ç çš„éªŒè¯ {#a-verification-using-poc}

ç°åœ¨æˆ‘ä»¬å°†ä½¿ç”¨ `gdb` æ‰“å°å‡ºå†…å­˜åŒºåŸŸå¹¶éªŒè¯ä»¥ä¸Šçš„è§£é‡Šåœ¨æˆ‘ä»¬çš„ä»£ç ä¸­æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚è¿™é‡Œæˆ‘å°†ä½¿ç”¨ [GEF](https://gef.readthedocs.io/en/master/commands/heap/#heap-chunk-command) çš„ `heap` åŠŸèƒ½æ¥æ›´å¥½åœ°æ˜¾ç¤º `malloc` åˆ†é…çš„ chunk çš„å±æ€§ã€‚

```
gefâ¤  heap chunk arr
Chunk(addr=0x55555556aeb0, size=0x30, flags=PREV_INUSE)
Chunk size: 48 (0x30)
Usable size: 40 (0x28)
Previous chunk size: 0 (0x0)
PREV_INUSE flag: On
IS_MMAPPED flag: Off
NON_MAIN_ARENA flag: Off

gefâ¤  x/16xw 0x55555556aeb0-16
0x55555556aea0:	0x00000000	0x00000000	0x00000031	0x00000000
0x55555556aeb0:	0x44434241	0x48474645	0x4c4b4a49	0x504f4e4d
0x55555556aec0:	0x54535251	0x58575655	0x00005a59	0x00000000
0x55555556aed0:	0x00000000	0x00000000	0x0000f131	0x00000000
```

å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œchunk çš„å¤§å°æ˜¯ 48 å­—èŠ‚ï¼Œå¯ç”¨å¤§å°ï¼ˆå®é™…å­˜å‚¨ç”¨æˆ·å†…å®¹çš„åŒºåŸŸï¼‰ä¸º 40 å­—èŠ‚ï¼Œè¦è¿œè¿œå¤§å‡ºæˆ‘ä»¬æ‰€è¯·æ±‚çš„ï¼ˆ26 ä¸ªå­—ç¬¦çš„æ•°ç»„ï¼Œåº”å½“å æ® 26 å­—èŠ‚çš„ç©ºé—´ï¼‰ã€‚è¿™æ˜¯å› ä¸º â€œchunk æ°¸è¿œå¼€å§‹äºåŒæ•° å­—ï¼ˆwordï¼‰çš„è¾¹ç•Œâ€¦â€¦å› æ­¤è‡³å°‘æ˜¯åŒå­—å¯¹é½çš„â€[^1]

[^1]: "chunks always begin on even word boundaries ... and thus at least double-word aligned."

:::info
ä¸€ä¸ª [å­—ï¼ˆwordï¼‰](<https://zh.wikipedia.org/zh-cn/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)>) çš„å¤§å°æ˜¯å–å†³äºç³»ç»Ÿæ¶æ„çš„ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œ64 ä½ç³»ç»Ÿçš„å­—é•¿ä¸º 64 æ¯”ç‰¹ï¼Œä¹Ÿå°±æ˜¯ 8 å­—èŠ‚ã€‚ç„¶è€Œï¼Œåœ¨ `gdb` çš„ `x/w` å‘½ä»¤ä¸­ï¼Œå­—é•¿ä¸ºå›ºå®šçš„ 32 æ¯”ç‰¹ï¼ˆ4 å­—èŠ‚ï¼‰ï¼Œéå¸¸ä»¤äººè¿·æƒ‘ã€‚å› æ­¤ï¼Œæˆ‘å°†ä½¿ç”¨â€œå­—â€ä»£æŒ‡ç°å®ä¸­çš„å–å†³äºç³»ç»Ÿçš„å¯å˜é•¿åº¦çš„å­—ï¼Œè€Œä½¿ç”¨â€œ32 æ¯”ç‰¹å­—â€ä»£æŒ‡ `gdb` ä¸­çš„å­—ã€‚
:::

å› ä¸ºå†…å­˜ä¸­çš„ chunk æ°¸è¿œæ˜¯åŒå­—å¯¹é½çš„ï¼Œæˆ‘ä»¬åº”è¯¥ä»åœ°å€ä¸­å‡å» $2\times8=16$ å­—èŠ‚æ¥è·å¾—æŒ‡å‘ `chunk` çš„æŒ‡é’ˆåœ°å€ã€‚è¿™é‡Œçš„ç¬¬ä¸€ä¸ªå­—ï¼ˆåœ¨ gdb ä¸­æ˜¾ç¤ºä¸ºä¸¤ä¸ª 32 æ¯”ç‰¹å­—ï¼‰è¢« `0x00` å¡«æ»¡äº†ï¼›å¹¶ä¸”å°†åœ¨ `P` flag è¢«å¤ä½æ—¶å¡«å…¥ä¸Šä¸€ä¸ª chunk çš„å¤§å°ã€‚

ç¬¬äºŒä¸ªå­— `0x31`ï¼ˆæˆ–æ˜¯ `0b110001`ï¼‰å­˜å‚¨äº†è¯¥ chunk çš„å¤§å°ä»¥åŠ 3 ä¸ª flagã€‚æœ€ä½æœ‰æ•ˆä½ï¼ˆLSBï¼‰`0b1` ä»£è¡¨ flag `P` (PREV_INUSE) è¢«è®¾ç½®äº†ï¼Œå› æ­¤ä¸Šä¸€ä¸ª chunk è¿˜æœªè¢«é‡Šæ”¾ã€‚å› ä¸ºæ‰€æœ‰ chunk çš„å¤§å°éƒ½å¿…é¡»è‡³å°‘æ˜¯ 8 å­—èŠ‚çš„æ•´æ•°å€ï¼Œå› æ­¤å…¶å¤§å°çš„ 3 ä¸ªæœ€ä½æœ‰æ•ˆä½éƒ½å¿…å®šä¸º 0ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¿™ä¸‰ä½ LSB èƒ½è¢«ç”¨ä½œ flagã€‚åœ¨è®¡ç®— chunk å¤§å°æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿç›´æ¥ä¸¢å¼ƒä¸‰ä½ LSB å¹¶å–å¾— `0b110000`ï¼ˆ`0x30`ï¼Œæˆ–æ˜¯ 48ï¼‰å­—èŠ‚ã€‚

:::note

å¦‚æœä½ è¶³å¤Ÿä»”ç»†çš„è¯ï¼Œä½ å¯èƒ½å·²ç»å‘ç°äº†ï¼šchunk çš„å¯ç”¨å¤§å°æ˜¯ 40 å­—èŠ‚ï¼Œåªæ¯” chunk å¤§å°å°äº† 8 å­—èŠ‚ï¼ˆè€Œä¸æ˜¯ 16ï¼‰ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå­—ã€‚

è¿™æ˜¯å› ä¸º `chunk` æŒ‡é’ˆ â€œæŒ‡å‘çš„å¹¶ä¸æ˜¯æœ¬ chunk çš„å¼€å§‹ï¼Œè€Œæ˜¯ä¸Šä¸€ chunk çš„æœ€åä¸€å­—â€[^2]ï¼ˆ[æ¥æº](https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F)ï¼‰ã€‚å®é™…ä¸Šï¼Œchunk å¼€å§‹äº `chunk` æŒ‡é’ˆæŒ‡å‘çš„åä¸€ä¸ªå­—ï¼ˆä¹Ÿå°±æ˜¯å­˜å‚¨ chunk å¤§å°çš„å­—ï¼‰ã€‚

[^2]: "does not point to the beginning of the chunk, but to the last word in the previous chunk"ï¼ˆ[æ¥æº](https://sourceware.org/glibc/wiki/MallocInternals#What_is_a_Chunk.3F)ï¼‰

:::

ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ â€œå®é™…çš„â€ chunk å¼€å§‹äºå†…å­˜åœ°å€ `0x55555556aea8` å¹¶ç»“æŸäº `0x55555556aec8`ã€‚æ•°æ®åŒºåŸŸå¼€å§‹äº `0x55555556aeb0` å¹¶ç»“æŸäº `0x55555556aec8`ã€‚åŒç†ï¼Œä¸‹ä¸€ä¸ª `chunk` æŒ‡é’ˆæŒ‡å‘çš„æ˜¯æœ¬ chunk çš„æ•°æ®åŒºåŸŸçš„æœ€åä¸€ä¸ªå­—ï¼ˆ`0x55555556aec8`ï¼‰ã€‚

æ—¢ç„¶å¦‚æ­¤ï¼Œä¸ºä»€ä¹ˆ chunk æŒ‡é’ˆä¼šä»¤äººè¿·æƒ‘åœ°æŒ‡å‘å‰ä¸€ chunk çš„æœ€åä¸€å­—å‘¢ï¼Ÿç­”æ¡ˆä¸ `free` è®¾è®¡çš„ç†å¿µæœ‰å…³ã€‚

å½“å‰ä¸€ä¸ª chunk è¢« free æ—¶ï¼Œå®ƒä¼šæŠŠæœ€åä¸€å­—å¡«å……ä¸ºå®ƒçš„å¤§å°ï¼Œå¹¶æ¸…é™¤ä¸‹ä¸€ä¸ª chunkï¼ˆæœ¬ chunkï¼‰ä¸­çš„ P flagã€‚è¿™æ ·ï¼Œæœ¬ chunk å°±å¯ä»¥é€šè¿‡è¿™ä¸ªå¤§å°åœ¨å‰ä¸€ chunk è¢«é‡Šæ”¾å â€œæ‰¾åˆ°å‰ä¸€ chunk çš„èµ·å§‹ä½ç½®â€ [^3]ã€‚

[^3]: "to find the front of the previous chunk"

### `free` æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ {#how-does-free-work}

åˆ°ç°åœ¨ï¼Œä½ åº”è¯¥å·²ç»çŸ¥é“ â€œ`delete[]` å¦‚ä½•çŸ¥é“å®ƒéœ€è¦é‡Šæ”¾å“ªå—å†…å­˜ï¼Ÿâ€ çš„ç­”æ¡ˆäº†ï¼šå› ä¸ºè¿™ä¸ª chunk çš„å¤§å°å°±è¢«å­˜å‚¨åœ¨å®ƒçš„å…ƒæ•°æ®ä¸­ã€‚

ä½†æ˜¯ï¼Œè¿˜æ˜¯æœ‰ä¸€äº›ç»†èŠ‚å€¼å¾—æˆ‘ä»¬è¿›è¡Œæ¢è®¨ï¼šä¸ºä»€ä¹ˆ chunk æŒ‡é’ˆè¦æŒ‡å‘ä¸Šä¸€ chunk çš„ç»“å°¾ï¼Ÿæˆ‘ä»¬ä¸ºä»€ä¹ˆéœ€è¦ `PREV_INUSE` (P) flagï¼Ÿä¸ºäº†è§£ç­”è¿™äº›ç–‘é—®ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ `free` æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚

:::note
åœ¨é˜…è¯»æœ¬èŠ‚æ—¶ï¼Œä½ å¯ä»¥ä¸ [`malloc_chunk` çš„ç»“æ„æ˜¯ä»€ä¹ˆæ ·çš„?](#how-are-malloc_chunks-structured) èŠ‚è¿›è¡Œäº¤å‰å¯¹ç…§ï¼Œä»¥æŸ¥çœ‹ chunk åœ¨ `free` å‰åçš„ç»“æ„åˆ†åˆ«æ˜¯ä»€ä¹ˆæ ·å­çš„ã€‚
:::

é•¿è¯çŸ­è¯´ï¼Œ`free` å¤§è‡´æ˜¯å¦‚ä¸‹å·¥ä½œçš„ã€‚å½“å®ƒè¢«è°ƒç”¨æ—¶ï¼ˆ[æºç ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l3237)ï¼‰ï¼Œç”¨æˆ·ä¼šä¼ ç»™å®ƒä¸€ä¸ªæŒ‡å‘æ•°æ®åœ°å€çš„æŒ‡é’ˆã€‚`free` åˆ™ä¼šè°ƒç”¨ `mem2chunk`ï¼ˆ[æºç ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l1310)ï¼‰å°†å…¶è½¬æ¢ä¸ºæŒ‡å‘ chunk å¤´çš„æŒ‡é’ˆã€‚
éšåï¼Œå¦‚æœè¿™ä¸€ chunk æ˜¯è¢« `mmap` åˆ†é…çš„ï¼ˆå¯ç”± M flag å¾—çŸ¥ï¼‰ï¼Œ`free` ä¼šè°ƒç”¨ `munmap`ï¼ˆ[man 3p](https://man.archlinux.org/man/munmap.3p.en) | [man 2](https://man.archlinux.org/man/munmap.2.en)ï¼‰è¿›è¡Œé‡Šæ”¾ï¼›å¦‚æœä¸æ˜¯ï¼Œå®ƒä¼šå°† chunk æŒ‡é’ˆä¼ ç»™ `_int_free`ï¼ˆ[æºç ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302)ï¼‰æ­£å¼è¿›è¡Œé‡Šæ”¾ã€‚

ç„¶è€Œï¼Œ `free` ä¸€ä¸ª chunk â€œå¹¶ä¸ä¼šå°†å…¶äº¤è¿˜æ“ä½œç³»ç»Ÿä»¥ç»™å…¶ä»–ç¨‹åºä½¿ç”¨ã€‚`free()` è°ƒç”¨ä»…ä»…æ˜¯å°†è¿™å—å†…å­˜æ ‡è®°ä¸º â€˜å¯è¢«æœ¬ç¨‹åºé‡æ–°ä½¿ç”¨â€™ï¼Œä½†å¯¹äºæ“ä½œç³»ç»Ÿè€Œè¨€ï¼Œè¿™å—å†…å­˜ä»ç„¶ â€˜å±äºâ€™ åº”ç”¨ç¨‹åºâ€[^4]ï¼ˆ[æ¥æº](https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm)ï¼‰çš„å †ä¸Šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå †ç®¡ç†å™¨ä»ç„¶éœ€è¦è¿½è¸ªè¿™å—å†…å­˜ï¼Œå¹¶åœ¨åˆé€‚çš„æ—¶å€™é‡æ–°ä½¿ç”¨å®ƒã€‚

[^4]: "does not actually return it to the operating system for other applications to use. The `free()` call marks a chunk of memory as 'free to be reused' by the application, but from the operating system's point of view, the memory still 'belongs' to the application"ï¼ˆ[æ¥æº](https://sourceware.org/glibc/wiki/MallocInternals#Free_Algorithm)ï¼‰

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬ä½¿ç”¨äº†ä¸€ä¸ªå¾ªç¯é“¾è¡¨æ¥ç»„ç»‡è¢« `free` çš„ chunk ä»¬ï¼Œå…¶ä¸­æ¯ä¸€ä¸ª chunk éƒ½å­˜å‚¨äº†æŒ‡å‘å‰ä¸€ä¸ªä¸åä¸€ä¸ª chunk çš„æŒ‡é’ˆã€‚æ­¤å¤–ï¼Œæ¯ä¸ª chunk çš„å¤§å°ä¼šè¢«å­˜å‚¨åœ¨å®ƒå†…å­˜çš„æœ€åä¸€ä¸ªå­—ï¼Œå³ä¸‹ä¸€ä¸ª chunk çš„ `chunk` æŒ‡é’ˆã€‚è¿™æ ·ä¸€æ¥ï¼Œä¸‹ä¸€ä¸ª chunk å¯ä»¥åˆ©ç”¨è¿™ä¸€å¤§å°è®¿é—®è¿™ä¸ªè¢« `free` çš„ chunk ä»¥åŠå®ƒçš„ headerã€‚å½“ä¸‹ä¸€ä¸ª chunk ä¹Ÿè¢« `free` æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿåˆ©ç”¨è¿™ä¸€å±æ€§æ¥ åˆå¹¶ï¼ˆ[coalesce](https://cs.stackexchange.com/a/18234)ï¼‰è¿™ä¸¤ä¸ª chunkã€‚

å½“ç„¶äº†ï¼Œå®é™…çš„ `free` æ“ä½œè¦è¿œæ¯”è¿™å¤æ‚ï¼Œä¸” chunk ä»¬ä¹Ÿä¼šä¸ºäº†æ›´é«˜æ•ˆçš„å†åˆ†é…ï¼ˆreallocationï¼‰è¢«æ”¾ç½®åˆ°ä¸åŒçš„ bin ä¸­ã€‚ ä½ å¯ä»¥é˜…è¯»å®˜æ–¹çš„ [glibc wiki](https://sourceware.org/glibc/wiki/MallocInternals)ï¼Œè¿™ç¯‡æ›´ä¸ºè¯¦ç»†çš„ [åšæ–‡](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/)ï¼Œæˆ–æ˜¯ [`_int_free` çš„æºç ](https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=e065785af77af72c17c773517c15b248b067b4ad;hb=ae37d06c7d127817ba43850f0f898b793d42aea7#l4302) ä»¥äº†è§£æ›´å¤šåº•å±‚ç»†èŠ‚ã€‚

## æˆ‘ä»¬å¦‚ä½•é¢„é˜²å†…å­˜æ³„æ¼ï¼Ÿ {#how-can-we-prevent-memory-leaks}

ç°åœ¨å¯èƒ½æ˜¯æ—¶å€™å›åˆ°æˆ‘ä»¬å¼€å§‹çš„ä¸»é¢˜äº†ï¼šæ—¢ç„¶æˆ‘ä»¬å·²ç»çŸ¥é“äº†å†…å­˜æ³„æ¼æ˜¯ä»€ä¹ˆï¼Œä»¥åŠå®ƒä»¬æ˜¯å¦‚ä½•å‘ç”Ÿçš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ‰ä»€ä¹ˆåŠæ³•é¢„é˜²å†…å­˜æ³„æ¼å—ï¼Ÿ

1. æ°¸è¿œ `delete` (`delete[]`) ä½¿ç”¨ `new` (`new[]`) åˆ›å»ºçš„å¯¹è±¡
   - è¿™æ˜¯æˆ‘ä»¬èƒ½åšçš„æœ€ç®€å•çš„äº‹æƒ…ï¼Œå¦‚æœä½ ä»ç„¶åšæŒä½¿ç”¨ `new` çš„è¯
2. é¿å…ç›´æ¥è°ƒç”¨ `new` ä¸ `delete`
   - [è¯´æ˜](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#r11-avoid-calling-new-and-delete-explicitly)ï¼ˆè‹±è¯­ï¼‰
   - **å¤ªé•¿ä¸çœ‹**ï¼šä½¿ç”¨èµ„æºå¥æŸ„ï¼ˆresource handleï¼‰è€Œä¸æ˜¯è£¸æŒ‡é’ˆï¼Œåè€…å…·æœ‰æ³„æ¼çš„å¯èƒ½æ€§ã€‚
   - è§£å†³æ–¹æ³•ï¼šä½¿ç”¨è¯¸å¦‚ `unique_ptr` ä¸ `shared_ptr` çš„æ™ºèƒ½æŒ‡é’ˆã€‚
3. ä¸è¦ç”¨è£¸æŒ‡é’ˆï¼ˆ`T*`ï¼‰æˆ–å¼•ç”¨ï¼ˆ`T&`ï¼‰æ¥è½¬ç§»æ‰€æœ‰æƒï¼ˆownershipï¼‰
   - [è¯´æ˜](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i11-never-transfer-ownership-by-a-raw-pointer-t-or-reference-t)ï¼ˆè‹±è¯­ï¼‰
   - **å¤ªé•¿ä¸çœ‹**ï¼šå®¹æ˜“äº§ç”Ÿâ€œè°åº”å½“åˆ é™¤æŒ‡é’ˆâ€çš„æ­§ä¹‰ã€‚
   - è§£å†³æ–¹æ³•ï¼šç›´æ¥ return å¯¹è±¡æœ¬èº«ï¼Œæˆ–æ˜¯ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œè¦æ±‚ç¨‹åºå‘˜æ‰‹åŠ¨é‡Šæ”¾èµ„æºæ˜¯å¾ˆå®¹æ˜“å‡ºé”™çš„ã€‚ä½ åº”è¯¥è€ƒè™‘ [ä½¿ç”¨èµ„æºå¥æŸ„å’Œ RAIIï¼ˆèµ„æºè·å–å³åˆå§‹åŒ–ï¼‰è‡ªåŠ¨ç®¡ç†èµ„æº](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rr-raii)ï¼ˆè‹±è¯­ï¼‰ã€‚

## å¼•ç”¨ & æ‰©å±•é˜…è¯» {#references--further-readings}

- Stroustrup, Bjarne and Sutter, Herb. ["C++ Core Guidelines"](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines). Updated Jun 17, 2021. Accessed Aug 08, 2021.
- glibc wiki. ["MallocInternals"](https://sourceware.org/glibc/wiki/MallocInternals). Updated May 20, 2019. Accessed Aug 08, 2021.
- Azeria Labs. ["Heap Exploitation Part 2: Understanding the Glibc Heap Implementation"](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/). Accessed Aug 08, 2021.
- CTF Wiki. ["å †ç›¸å…³æ•°æ®ç»“æ„"](https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/heap-structure/) (in Chinese). Accessed Aug 10, 2021.
- glibc Contributors. [glibc v2.34 source code](https://sourceware.org/git/?p=glibc.git;a=tree;h=6eb9f63e6c9197e967a8cc12a8b235335e5a873d;hb=ae37d06c7d127817ba43850f0f898b793d42aea7). Aug 2, 2021. Accessed Aug 8, 2021.
- gcc Contributors. [gcc v11.2.0 source code](https://github.com/gcc-mirror/gcc/tree/releases/gcc-11.2.0). Jul 28, 2021. Accessed Aug 8, 2021.
- StackOverflow. ["How does delete[] know the size of the operand array?"](https://stackoverflow.com/questions/197675/how-does-delete-know-the-size-of-the-operand-array)

é¡ºå¸¦ä¸€æï¼Œåœ¨æœç´¢å†…å­˜æ³„æ¼çš„æ—¶å€™ï¼Œæˆ‘åœ¨ Brookhaven National Lab çš„åŸŸåä¸‹é¢å‘ç°äº†ä¸€ä¸ª å¤§äºšæ¹¾ååº”å †ä¸­å¾®å­å®éªŒçš„ wiki é¡µé¢ ["Dealing With Memory Leaks"](https://wiki.bnl.gov/dayabay/index.php?title=Dealing_With_Memory_Leaks)ã€‚æˆ‘éƒ½ä¸çŸ¥é“å¤§äºšæ¹¾ååº”å †è¿˜æœ‰ä¸€ä¸ªå›½é™…ç ”ç©¶é¡¹ç›® ğŸ˜‚
